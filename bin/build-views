#!/usr/bin/env node

const _ = require('underscore');
const cmdline = require('command-line-args');
const usage = require('command-line-usage');
const fs = require('fs');
const mkdirp = require('mkdirp');
const path = require('path')
const rimraf = require('rimraf');
const walk = require('walk');

// Configuration constants
const OutputDir = __dirname + '/../.build/';
const MetadataFileName="metadata.jsonld";

var metadataCache = {};

// Define the command line args and parse to see what we got
const cmdlineDefs = [
        { name: "help", alias: "h", type: Boolean },
        { name: "rootdir", alias: "r", type: String, description: "Root directory with JSON-LD files to be processed to views" },
        { name: "output", alias: "o", type: String, defaultValue: OutputDir, description: "Views output directory" }
];

function canonicalPath(root) { 
    return path.isAbsolute(root) ? root : process.cwd() + '/' + root;
}

function help(status) {
    console.log(
        usage([
           { header:"build-views",
            content:"Recursively walk the specified root source directory tree, and generate the views." },
           { header: 'Synopsis',
             content: [
                '$ build-views [bold]{--rootdir} [underline]{directory} [[bold]{--output} [underline]{directory}]',
                '$ build-views [bold]{--help}'
             ]},
           { header: 'Options',
             optionList: [
                 { name: 'rootdir', 
                   typeLabel: '[underline]{directory}',
                   description: 'The root directory from which view data should be found and processed.'},
                 { name: 'output', 
                   typeLabel: '[underline]{directory}',
                   description: 'The views output directory.'}
              ]
            },
            { content: "Project home: [underline]{https://github.com/mappinghub/views}" }
        ])
    );
    process.exit(status);
}

function outputPath(cmdArgs) { 
    var outputDir = path.isAbsolute(cmdArgs.output) ? cmdArgs.output : process.cwd() + cmdArgs.output;
    return outputDir.endsWith('/') ? outputDir : outputDir + '/';
}

function rootPath(cmdArgs) {
    if (_.isEmpty(cmdArgs.rootdir)) { 
        console.error('Expected a rootdir from which to begin processing the views input data!');
        help(1);
    }
    return cmdArgs.rootdir.endsWith('/') ? cmdArgs.rootdir : cmdArgs.rootdir + '/';
}

/**
 * Create a clean directory.  If the directory exists, it will be deleted and recreated.
 *
 * @param dirpath target directory path
 */
function createCleanDir(dirpath) { 
    try { 
        rimraf.sync(dirpath);
        fs.mkdirSync(dirpath);
    } catch (e) {  
        console.error('Unable to clean directory '+dirpath+':',e);
        process.exit(1);
    }
}

/** 
 * Read and parse JSON file content.  Replace this with a load to an RDF store.
 *
 * @param canoncial file name
 * 
 * @return a Javascript object with the JSON file content
 */
function fileContent(filename) {
    try {
        return JSON.parse(fs.readFileSync(filename, 'utf-8'));
    } catch(e) {
        console.error("Unable to process file " + filename + ": " + e.message);
        process.exit(1);
    }
}

/** 
 * Merge two hashes, by copying all attributes in the newHAsh into the targetHash. 
 * 
 * @param newHash new hash with attributes to be merged into the target hash.
 *
 * @return the targetHash
 */
function merge(newHash, targetHash) { 
    _.mapObject(newHash, function(val, key) { 
        if (!_.isEmpty(targetHash[key]) && val !== targetHash[key]) {
            console.warn("Overriding " + key + ": " + targetHash[key] + " with " + key + ": " + val);
        }
        targetHash[key] = val; 
    });

    return targetHash;
}

/**
 * Read a metadata file (specified by dirpath + filename) and combine it with existing metadata.
 * Save the resulting metadata to the cache so we only read the file once.
 * 
 * @path dirpath to the metadata file to be read.  
 * @filename metadata file name
 * @param metadata current metadata
 * @param metadataCache metadata cache.  This uses the metadata dirpath as a key, and simply saves 
 *        the metadata content
 */
function processMetadata(dirpath, filename, metadata, metadataCache) {
    merge(fileContent(dirpath + filename), metadata); 
    metadataCache[dirpath] = metadata;
}

/**
 * Walks a directory tree, processing directories and files.
 * 
 * @param viewpath path to the input data for the views
 * @param outpath path to the directory where view content should be written
 * @param metadata aggregated metadata 
 * 
 * @return a promise to complete the view generation or reject it on error
 */
function walkTree(viewpath, outpath, metadata) { 

    return new Promise(function(resolve, reject) {

      var options = {
        filters: ["bin"],
        followLinks: false,
        listeners: {

            directories: function (root, dirStatsArray, next) {
                dirStatsArray.forEach(function(dir) { 
                    if (!dir.name.startsWith('.')) {
                       walkTree(viewpath + dir.name + '/',
                                outpath + dir.name + '/',
                                _.clone(metadata));
                    }
                });
                next();
            },

            file: function (root, fileStats, next) {
                var filename = fileStats.name;

                if (filename === MetadataFileName) { 
                    // Read metadata file and add it to the metadata cache
                    processMetadata(viewpath, filename, metadata, metadataCache);

                } else {
                    var content = fileContent(viewpath + filename);
                    if (_.isUndefined(metadataCache[viewpath]) && fs.existsSync(viewpath + MetadataFileName)) {
                        // We have unread sibling metadata in this directory - read and cache it now
                        processMetadata(viewpath, MetadataFileName, metadata, metadataCache);
                    }
                    metadata = metadataCache[viewpath] || metadata;
                    merge(metadata, content);
                    if (!fs.existsSync(outpath)) { 
                       mkdirp.sync(outpath); 
                    }
console.log('writing ',outpath + filename);
                    fs.writeFileSync(outpath + filename, JSON.stringify(content, null, 2));
                }
                next();
            },

            errors: function (root, nodeStatsArray, next) {
                reject(Error('Unable to process',root,': ',nodeStatsArray));
            }, 

            end: function() { 
                resolve();
            }
        }
      };

      walk.walk(viewpath, options);
    });
}

/** 
 * Get a list of the directories under dirpath filtering out any hidden ones.
 */
function visibleDirectories(dirpath) {
  return fs.readdirSync(dirpath)
    .filter(file => fs.statSync(path.join(dirpath, file)).isDirectory() && !file.startsWith('.'))
}

/************************  Main ****************************/

try {
    const cmdArgs = cmdline(cmdlineDefs)
} catch(e) {
   console.error(e.message);
   help(1);
}

if (cmdArgs.help) help(0);

const rootDir = rootPath(cmdArgs);
const outputDir = outputPath(cmdArgs);

createCleanDir(outputDir);

// Walk each directory, building the metadata and files
_.map(
    visibleDirectories(rootDir), function(dir) { 
        var viewpath =  canonicalPath(rootDir) + dir  + '/';
        var outpath = canonicalPath(outputDir) + dir + '/';
console.log('viewpath=',viewpath,', out=',outpath);
        var metadata = {};

        walkTree(viewpath, outpath, metadata).then(function(results) { 
            // Add summary generation code here
            console.log('generate summary');
        });
    }
);
